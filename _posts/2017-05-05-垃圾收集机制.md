---
permalink: /posts/java-gc
layout: post
title:  垃圾收集机制
categories: java
tags:
---

* content
{:toc}

垃圾收集机制




*GC(Garbage Collection)*

## 对象标记(判断对象存活的)算法

### 1. 引用计数方法
对于每一个对象,有一个引用计数+1,取消一个引用计数-1

缺点: 无法处理循环引用

### 2. 根搜索算法
以一系列GC ROOTS对象作为起点,从这些起点向下搜索过的路径称为引用链

## 机制

采用`分代收集`算法,此算法的基本假设: 绝大部分对象的生命周期都非常短暂,存活时间短.

新生区(`Young Generation`)包括`Eden`与`Survivor`,老生区(`Old Generation`)包括`Tenured`.

每次GC时,新生区一般大部分对象死去,只剩少量存活对象,因此适合用`复制`算法(只需要付出少量复制成本);老生区对象存活率高,没有额外的空间进行分配担保,因此一般使用`标记-清除`或`标记-整理`算法

### 1. 标记-清除
*也叫标记-清理*

分为两个阶段: 标记与清除.

先标记需要回收的对象,标记完成之后再统一清除.

缺点:
1. 效率不高
2. 会产生大量不连续的内存碎片

### 2. 复制
将内存分为容量相同的两块,每次只使用一块.
当这一块使用完后,将存活的对象复制到另一块

缺点:
1. 内存减半

### 3. 标记-整理
与标记-清除类似,先标记,标记完成之后,将存活对象向一端移动,然后直接清理掉边界之外的内存

缺点:
1. 成本更高

## 流程

开始新建对象会进入`Eden`,在GC时没有被清理的会进入`Survivor`,对象在Survivor Space中存在一段时间后,会进入`Tenured`

当普通的GC后空间仍然不够时,会进行FULL GC,停止所有在堆中的线程并执行清除动作
